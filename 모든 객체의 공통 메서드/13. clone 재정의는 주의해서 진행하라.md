# clone 재정의는 주의해서 진행하라

메서드 하나 없는 `Cloneable` 인터페이스는 무슨일을 할까?

이 인터페이스는 놀랍게도 Object 의 protected 메서드인 clone 의 동작 방식을 결정한다. 즉, Cloneable 인터페이스를 구현한 인스턴스에서 clone 메서드를 호출하면
그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 `CloneNotSupportedException`을 던진다.

명세에서 이야기하지 않지만, __실무에서 Cloneable 을 구현한 클래스는 clone 메서드를 public 으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.__

## 정리

Cloneable 이 몰고 온 모든 문제를 되짚어봤을 때, 새로운 인터페이스를 만들 때는 절대 Cloneable 을 확장해서는 안 되며, 새로운 클래스도 이를 구현해서는 안 된다. final 클래스라면 Cloneable 을
구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 한다. 기본 원칙은 `복제 기능은 생성자와 팩터리를 이용하는게 최고`라는 것이다.
단, 배열만은 clone 메서드 방식이 가장 깔끔한, 이 규칙의 합당한 예외라고 할 수 있다.
